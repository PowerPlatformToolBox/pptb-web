name: Convert and Update Tool

on:
    workflow_dispatch:
        inputs:
            tool_id:
                description: "Tool ID (npm package name)"
                required: true
                type: string
            version:
                description: "Version to convert"
                required: true
                type: string
            authors:
                description: "Authors of the tool"
                required: true
                type: string
            branch:
                description: "Branch to commit to (optional, defaults to current branch)"
                required: false
                type: string

jobs:
    convert:
        runs-on: ubuntu-latest
        permissions: write-all
        env:
            SUPPORTED_ICON_FORMATS: "png|jpg|jpeg|svg"

        steps:
            - name: Checkout repository
              uses: actions/checkout@v4
              with:
                  token: ${{ secrets.GITHUB_TOKEN }}
                  ref: ${{ inputs.branch || github.ref }}

            - name: Setup Node.js
              uses: actions/setup-node@v4
              with:
                  node-version: "20"

            - name: Get tool metadata from Supabase
              id: metadata
              env:
                  SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
                  SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
              run: |
                  # Read existing tool metadata from Supabase
                  TOOL_ID=$(echo "${{ inputs.tool_id }}" | sed 's/@//g' | sed 's/\//-/g')
                  TOOL_PACKAGE_NAME="${{ inputs.tool_id }}"

                  # URL-encode the package name for the query
                  ENCODED_PACKAGE=$(echo "$TOOL_PACKAGE_NAME" | jq -sRr @uri)

                  # Fetch tool from Supabase by packagename
                  HTTP_CODE=$(curl -s -w "%{http_code}" -o /tmp/tool_response.json \
                    "$SUPABASE_URL/rest/v1/tools?packagename=eq.$ENCODED_PACKAGE&select=name,description,author,readmeurl,iconurl" \
                    -H "apikey: $SUPABASE_ANON_KEY" \
                    -H "Authorization: Bearer $SUPABASE_ANON_KEY")
                  TOOL_RESPONSE=$(cat /tmp/tool_response.json)

                  # Check HTTP status code
                  if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
                    echo "⚠️ Failed to fetch tool from Supabase (HTTP $HTTP_CODE), using defaults"
                    TOOL_RESPONSE="[]"
                  fi

                  # Check if response is valid JSON array
                  if ! echo "$TOOL_RESPONSE" | jq -e 'type == "array"' > /dev/null 2>&1; then
                    echo "⚠️ Invalid response from Supabase, using defaults"
                    TOOL_RESPONSE="[]"
                  fi

                  # Parse response (returns array, get first element or use defaults)
                  TOOL_NAME=$(echo "$TOOL_RESPONSE" | jq -r '.[0].name // "${{ inputs.tool_id }}"')
                  TOOL_DESC=$(echo "$TOOL_RESPONSE" | jq -r '.[0].description // "Power Platform Tool"')
                  TOOL_AUTHOR=$(echo "$TOOL_RESPONSE" | jq -r '.[0].author // ""')
                  README_URL=$(echo "$TOOL_RESPONSE" | jq -r '.[0].readmeurl // ""')
                  ICON_URL=$(echo "$TOOL_RESPONSE" | jq -r '.[0].iconurl // empty')

                  echo "id=$TOOL_ID" >> $GITHUB_OUTPUT
                  echo "package_name=$TOOL_PACKAGE_NAME" >> $GITHUB_OUTPUT
                  echo "name=$TOOL_NAME" >> $GITHUB_OUTPUT
                  echo "description=$TOOL_DESC" >> $GITHUB_OUTPUT
                  echo "author=$TOOL_AUTHOR" >> $GITHUB_OUTPUT
                  echo "readme_url=$README_URL" >> $GITHUB_OUTPUT
                  echo "icon_url=$ICON_URL" >> $GITHUB_OUTPUT

            - name: Download and build tool
              id: build
              run: |
                  # Download specific version from npm
                  npm pack ${{ inputs.tool_id }}@${{ inputs.version }}

                  # Extract
                  tar -xzf *.tgz
                  cd package

                  # Verify version
                  VERSION=$(node -p "require('./package.json').version")
                  echo "version=$VERSION" >> $GITHUB_OUTPUT

                  # Install production dependencies
                  npm install --production --no-optional

                  # Run build if script exists
                  npm run --if-present build || echo "No build script found or build failed"

                  cd ..

            - name: Create distribution archive
              run: |
                  cd package

                  # Remove unnecessary files
                  rm -rf .git .github node_modules/*/test node_modules/*/tests
                  rm -rf node_modules/*/*.md node_modules/*/.npmignore
                  find . -name "*.map" -delete
                  find . -name "*.ts" ! -name "*.d.ts" -delete

                  # Create archive
                  tar -czf ../${{ steps.metadata.outputs.id }}-${{ inputs.version }}.tar.gz \
                    --exclude=node_modules/.bin \
                    .

                  cd ..

            - name: Generate checksum
              id: checksum
              run: |
                  CHECKSUM=$(sha256sum ${{ steps.metadata.outputs.id }}-${{ inputs.version }}.tar.gz | awk '{print $1}')
                  SIZE=$(stat -f%z ${{ steps.metadata.outputs.id }}-${{ inputs.version }}.tar.gz 2>/dev/null || stat -c%s ${{ steps.metadata.outputs.id }}-${{ inputs.version }}.tar.gz)

                  echo "checksum=$CHECKSUM" >> $GITHUB_OUTPUT
                  echo "size=$SIZE" >> $GITHUB_OUTPUT

            - name: Download icon
              id: icon
              if: steps.metadata.outputs.icon_url != ''
              run: |
                  ICON_URL="${{ steps.metadata.outputs.icon_url }}"

                  # Extract file extension from URL
                  EXTENSION="${ICON_URL##*.}"
                  # Remove query parameters if any
                  EXTENSION="${EXTENSION%%\?*}"
                  # Convert to lowercase for validation
                  EXTENSION=$(echo "$EXTENSION" | tr '[:upper:]' '[:lower:]')

                  # Validate extension against supported formats using case statement
                  case "$EXTENSION" in
                    png|jpg|jpeg|svg)
                      echo "✅ Valid icon format: $EXTENSION"
                      ;;
                    *)
                      echo "⚠️ Invalid or unsupported icon format: $EXTENSION"
                      echo "Supported formats: $SUPPORTED_ICON_FORMATS"
                      echo "Defaulting to png"
                      EXTENSION="png"
                      ;;
                  esac

                  # Determine icon filename
                  ICON_FILENAME="${{ steps.metadata.outputs.id }}-${{ inputs.version }}-icon.${EXTENSION}"

                  echo "Downloading icon from: $ICON_URL"
                  if curl -L -f -o "$ICON_FILENAME" "$ICON_URL"; then
                    echo "✅ Icon downloaded successfully"
                    echo "filename=$ICON_FILENAME" >> $GITHUB_OUTPUT
                    echo "has_icon=true" >> $GITHUB_OUTPUT
                  else
                    echo "⚠️ Failed to download icon, continuing without it"
                    echo "has_icon=false" >> $GITHUB_OUTPUT
                  fi

            - name: Prepare release files
              id: release_files
              run: |
                  # Build files list
                  FILES="${{ steps.metadata.outputs.id }}-${{ inputs.version }}.tar.gz"
                  if [ "${{ steps.icon.outputs.has_icon }}" = "true" ]; then
                    FILES="${FILES}"$'\n'"${{ steps.icon.outputs.filename }}"
                  fi

                  # Output as multiline string
                  echo "files<<EOF" >> $GITHUB_OUTPUT
                  echo "$FILES" >> $GITHUB_OUTPUT
                  echo "EOF" >> $GITHUB_OUTPUT

            - name: Upload to GitHub Release
              id: upload
              uses: softprops/action-gh-release@v1
              with:
                  tag_name: ${{ steps.metadata.outputs.id }}-${{ inputs.version }}
                  name: ${{ steps.metadata.outputs.name }} v${{ inputs.version }}
                  body: |
                      Tool: ${{ steps.metadata.outputs.name }}
                      npm package: ${{ inputs.tool_id }}
                      Version: ${{ inputs.version }}

                      Automated update from update checker.
                  files: ${{ steps.release_files.outputs.files }}

            - name: Update Supabase database
              env:
                  SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
                  SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
              if: env.SUPABASE_URL != '' && env.SUPABASE_SERVICE_ROLE_KEY != ''
              run: |
                  # Prepare icon URL
                  if [ "${{ steps.icon.outputs.has_icon }}" = "true" ]; then
                    ICON_URL="https://github.com/${{ github.repository }}/releases/download/${{ steps.metadata.outputs.id }}-${{ inputs.version }}/${{ steps.icon.outputs.filename }}"
                  else
                    ICON_URL=""
                  fi

                  # Get download URL from release
                  DOWNLOAD_URL="https://github.com/${{ github.repository }}/releases/download/${{ steps.metadata.outputs.id }}-${{ inputs.version }}/${{ steps.metadata.outputs.id }}-${{ inputs.version }}.tar.gz"

                  # Prepare SQL payload for tools table
                  TOOL_PAYLOAD=$(jq -n \
                    --arg packagename "${{ steps.metadata.outputs.package_name }}" \
                    --arg version "${{ inputs.version }}" \
                    --arg downloadurl "$DOWNLOAD_URL" \
                    --arg iconurl "$ICON_URL" \
                    --arg published "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                    --arg checksum "${{ steps.checksum.outputs.checksum }}" \
                    --arg size "${{ steps.checksum.outputs.size }}" \
                    '{
                      packagename: $packagename,
                      version: $version,
                      downloadurl: $downloadurl,
                      iconurl: $iconurl,
                      published_at: $published,
                      checksum: $checksum,
                      size: ($size|tonumber)
                    }')

                  # Update existing tool metadata in Supabase (not insert - tool should already exist)
                  ENCODED_PACKAGE=$(echo "${{ steps.metadata.outputs.package_name }}" | jq -sRr @uri)
                  RESPONSE=$(curl -X PATCH "${{ secrets.SUPABASE_URL }}/rest/v1/tools?packagename=eq.$ENCODED_PACKAGE" \
                    -H "apikey: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
                    -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
                    -H "Content-Type: application/json" \
                    -H "Prefer: return=representation" \
                    -d "$TOOL_PAYLOAD")

                  echo "Supabase tools response: $RESPONSE"

                  # Extract the tool_id from response (response is array)
                  TOOL_ID=$(echo "$RESPONSE" | jq -r '.[0].id // empty')

                  if [ -n "$TOOL_ID" ]; then
                    echo "Tool metadata updated with ID: $TOOL_ID"
                    echo "Analytics data preserved from previous version"

                    AUTHOR_LIST="${{ inputs.authors }}"
                    if [ -n "$AUTHOR_LIST" ]; then
                      IFS=',' read -ra AUTHORS <<< "$AUTHOR_LIST"
                      for RAW_AUTHOR in "${AUTHORS[@]}"; do
                        AUTHOR_NAME=$(echo "$RAW_AUTHOR" | xargs)
                        if [ -z "$AUTHOR_NAME" ]; then
                          continue
                        fi

                        ENCODED_NAME=$(jq -rn --arg v "$AUTHOR_NAME" '$v|@uri')
                        CONTRIBUTOR_LOOKUP=$(curl -s "${{ secrets.SUPABASE_URL }}/rest/v1/contributors?name=eq.${ENCODED_NAME}&select=id&limit=1" \
                          -H "apikey: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
                          -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
                          -H "Content-Type: application/json")
                        CONTRIBUTOR_ID=$(echo "$CONTRIBUTOR_LOOKUP" | jq -r '.[0].id // empty')

                        if [ -z "$CONTRIBUTOR_ID" ]; then
                          CONTRIBUTOR_PAYLOAD=$(jq -n --arg name "$AUTHOR_NAME" '{name: $name}')
                          CONTRIBUTOR_RESPONSE=$(curl -s -X POST "${{ secrets.SUPABASE_URL }}/rest/v1/contributors?select=id" \
                            -H "apikey: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
                            -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
                            -H "Content-Type: application/json" \
                            -H "Prefer: return=representation" \
                            -d "$CONTRIBUTOR_PAYLOAD")
                          CONTRIBUTOR_ID=$(echo "$CONTRIBUTOR_RESPONSE" | jq -r '.[0].id // empty')
                        fi

                        if [ -n "$CONTRIBUTOR_ID" ]; then
                          TOOL_CONTRIBUTOR_PAYLOAD=$(jq -n \
                            --arg tool_id "$TOOL_ID" \
                            --arg contributor_id "$CONTRIBUTOR_ID" \
                            '{tool_id: $tool_id, contributor_id: ($contributor_id|tonumber)}')

                          curl -s -X POST "${{ secrets.SUPABASE_URL }}/rest/v1/tool_contributors" \
                            -H "apikey: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
                            -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
                            -H "Content-Type: application/json" \
                            -H "Prefer: resolution=ignore-duplicates" \
                            -d "$TOOL_CONTRIBUTOR_PAYLOAD" >/dev/null || true

                          echo "Contributor linked: $AUTHOR_NAME"
                        else
                          echo "Warning: Failed to upsert contributor for author '$AUTHOR_NAME'"
                        fi
                      done
                    fi
                  else
                    echo "Warning: Could not extract tool ID from Supabase response"
                  fi
