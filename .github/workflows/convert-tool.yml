name: Convert and Publish Tool

on:
    issues:
        types: [labeled]

jobs:
    convert:
        if: github.event.label.name == 'approved'
        runs-on: ubuntu-latest
        permissions: write-all
        env:
            SUPPORTED_ICON_FORMATS: "png|jpg|jpeg|svg"

        steps:
            - name: Checkout repository
              uses: actions/checkout@v4
              with:
                  token: ${{ secrets.GITHUB_TOKEN }}

            - name: Setup Node.js
              uses: actions/setup-node@v4
              with:
                  node-version: "20"

            - name: Parse issue form
              id: parse
              uses: stefanbuck/github-issue-parser@v3

            - name: Extract tool info
              id: tool
              run: |
                  PACKAGE_NAME=$(echo '${{ steps.parse.outputs.jsonString }}' | jq -r '.npm_package_name')
                  DISPLAY_NAME=$(echo '${{ steps.parse.outputs.jsonString }}' | jq -r '.display_name')
                  DESCRIPTION=$(echo '${{ steps.parse.outputs.jsonString }}' | jq -r '.description')
                  AUTHOR=$(echo '${{ steps.parse.outputs.jsonString }}' | jq -r '.author')
                  CATEGORY=$(echo '${{ steps.parse.outputs.jsonString }}' | jq -r '.category')
                  README_URL=$(echo '${{ steps.parse.outputs.jsonString }}' | jq -r '.readme_url')
                  ICON_URL=$(echo '${{ steps.parse.outputs.jsonString }}' | jq -r '.icon_url // empty')

                  echo "package=$PACKAGE_NAME" >> $GITHUB_OUTPUT
                  echo "name=$DISPLAY_NAME" >> $GITHUB_OUTPUT
                  echo "description=$DESCRIPTION" >> $GITHUB_OUTPUT
                  echo "author=$AUTHOR" >> $GITHUB_OUTPUT
                  echo "category=$CATEGORY" >> $GITHUB_OUTPUT
                  echo "readme_url=$README_URL" >> $GITHUB_OUTPUT
                  echo "icon_url=$ICON_URL" >> $GITHUB_OUTPUT

            - name: Download and build tool
              id: build
              run: |
                  # Download from npm
                  npm pack ${{ steps.tool.outputs.package }}

                  # Extract
                  tar -xzf *.tgz
                  cd package

                  # Get version from package.json
                  VERSION=$(node -p "require('./package.json').version")
                  echo "version=$VERSION" >> $GITHUB_OUTPUT

                  # Install production dependencies
                  npm install --production --no-optional

                  # Run build if script exists
                  npm run --if-present build || echo "No build script found or build failed"

                  # Create tool ID (kebab-case)
                  TOOL_ID=$(echo "${{ steps.tool.outputs.package }}" | sed 's/@//g' | sed 's/\//-/g')
                  echo "id=$TOOL_ID" >> $GITHUB_OUTPUT

                  cd ..

            - name: Create distribution archive
              run: |
                  cd package

                  # Remove unnecessary files
                  rm -rf .git .github node_modules/*/test node_modules/*/tests
                  rm -rf node_modules/*/*.md node_modules/*/.npmignore
                  find . -name "*.map" -delete
                  find . -name "*.ts" ! -name "*.d.ts" -delete

                  # Create archive
                  tar -czf ../${{ steps.build.outputs.id }}-${{ steps.build.outputs.version }}.tar.gz \
                    --exclude=node_modules/.bin \
                    package.json \
                    dist/

                  cd ..

            - name: Generate checksum
              id: checksum
              run: |
                  CHECKSUM=$(sha256sum ${{ steps.build.outputs.id }}-${{ steps.build.outputs.version }}.tar.gz | awk '{print $1}')
                  SIZE=$(stat -f%z ${{ steps.build.outputs.id }}-${{ steps.build.outputs.version }}.tar.gz 2>/dev/null || stat -c%s ${{ steps.build.outputs.id }}-${{ steps.build.outputs.version }}.tar.gz)

                  echo "checksum=$CHECKSUM" >> $GITHUB_OUTPUT
                  echo "size=$SIZE" >> $GITHUB_OUTPUT

            - name: Download icon
              id: icon
              if: steps.tool.outputs.icon_url != ''
              run: |
                  ICON_URL="${{ steps.tool.outputs.icon_url }}"

                  # Extract file extension from URL
                  EXTENSION="${ICON_URL##*.}"
                  # Remove query parameters if any
                  EXTENSION="${EXTENSION%%\?*}"
                  # Convert to lowercase for validation
                  EXTENSION=$(echo "$EXTENSION" | tr '[:upper:]' '[:lower:]')

                  # Validate extension against supported formats using case statement
                  case "$EXTENSION" in
                    png|jpg|jpeg|svg)
                      echo "✅ Valid icon format: $EXTENSION"
                      ;;
                    *)
                      echo "⚠️ Invalid or unsupported icon format: $EXTENSION"
                      echo "Supported formats: $SUPPORTED_ICON_FORMATS"
                      echo "Defaulting to png"
                      EXTENSION="png"
                      ;;
                  esac

                  # Determine icon filename
                  ICON_FILENAME="${{ steps.build.outputs.id }}-${{ steps.build.outputs.version }}-icon.${EXTENSION}"

                  echo "Downloading icon from: $ICON_URL"
                  if curl -L -f -o "$ICON_FILENAME" "$ICON_URL"; then
                    echo "✅ Icon downloaded successfully"
                    echo "filename=$ICON_FILENAME" >> $GITHUB_OUTPUT
                    echo "has_icon=true" >> $GITHUB_OUTPUT
                  else
                    echo "⚠️ Failed to download icon, continuing without it"
                    echo "has_icon=false" >> $GITHUB_OUTPUT
                  fi

            - name: Prepare release files
              id: release_files
              run: |
                  # Build files list
                  FILES="${{ steps.build.outputs.id }}-${{ steps.build.outputs.version }}.tar.gz"
                  if [ "${{ steps.icon.outputs.has_icon }}" = "true" ]; then
                    FILES="${FILES}"$'\n'"${{ steps.icon.outputs.filename }}"
                  fi

                  # Output as multiline string
                  echo "files<<EOF" >> $GITHUB_OUTPUT
                  echo "$FILES" >> $GITHUB_OUTPUT
                  echo "EOF" >> $GITHUB_OUTPUT

            - name: Upload to GitHub Release
              id: upload
              uses: softprops/action-gh-release@v1
              with:
                  tag_name: ${{ steps.build.outputs.id }}-${{ steps.build.outputs.version }}
                  name: ${{ steps.tool.outputs.name }} v${{ steps.build.outputs.version }}
                  body: |
                      Tool: ${{ steps.tool.outputs.name }}
                      npm package: ${{ steps.tool.outputs.package }}
                      Version: ${{ steps.build.outputs.version }}
                      Author: ${{ steps.tool.outputs.author }}

                      Submitted via issue #${{ github.event.issue.number }}
                  files: ${{ steps.release_files.outputs.files }}

            - name: Update Supabase database
              env:
                  SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
                  SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
              if: env.SUPABASE_URL != '' && env.SUPABASE_SERVICE_ROLE_KEY != ''
              run: |
                  # Prepare icon URL
                  if [ "${{ steps.icon.outputs.has_icon }}" = "true" ]; then
                    ICON_URL="https://github.com/${{ github.repository }}/releases/download/${{ steps.build.outputs.id }}-${{ steps.build.outputs.version }}/${{ steps.icon.outputs.filename }}"
                  else
                    ICON_URL=""
                  fi

                  # Prepare SQL payload for tools table
                  TOOL_PAYLOAD=$(jq -n \
                    --arg packageName "${{ steps.tool.outputs.package }}" \
                    --arg name "${{ steps.tool.outputs.name }}" \
                    --arg description "${{ steps.tool.outputs.description }}" \
                    --arg iconUrl "$ICON_URL" \
                    --arg author "${{ steps.tool.outputs.author }}" \
                    --arg version "${{ steps.build.outputs.version }}" \
                    --arg category "${{ steps.tool.outputs.category }}" \
                    --arg published "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                    '{
                      packageName: $packageName,
                      name: $name,
                      description: $description,
                      iconUrl: $iconUrl,
                      author: $author,
                      version: $version,
                      category: $category,
                      published_at: $published
                    }')

                  # Insert or update tool metadata in Supabase
                  RESPONSE=$(curl -X POST "${{ secrets.SUPABASE_URL }}/rest/v1/tools" \
                    -H "apikey: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
                    -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
                    -H "Content-Type: application/json" \
                    -H "Prefer: resolution=merge-duplicates,return=representation" \
                    -d "$TOOL_PAYLOAD")

                  echo "Supabase tools response: $RESPONSE"

                  # Extract the tool_id from response
                  TOOL_ID=$(echo "$RESPONSE" | jq -r '.[0].id // empty')

                  if [ -n "$TOOL_ID" ]; then
                    echo "Tool inserted/updated with ID: $TOOL_ID"
                    
                    # Initialize analytics for the tool
                    ANALYTICS_PAYLOAD=$(jq -n \
                      --arg tool_id "$TOOL_ID" \
                      '{
                        tool_id: $tool_id,
                        downloads: 0,
                        rating: 0.0,
                        aum: 0
                      }')

                    curl -X POST "${{ secrets.SUPABASE_URL }}/rest/v1/tool_analytics" \
                      -H "apikey: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
                      -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
                      -H "Content-Type: application/json" \
                      -H "Prefer: resolution=merge-duplicates" \
                      -d "$ANALYTICS_PAYLOAD"
                    
                    echo "Analytics initialized for tool"
                  else
                    echo "Warning: Could not extract tool ID from Supabase response"
                  fi

            - name: Close issue with success
              uses: actions/github-script@v7
              with:
                  script: |
                      const creator = context.payload.sender.login;
                                  
                      await github.rest.issues.createComment({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: context.issue.number,
                        body: `## ✅ Tool Published Successfully!\n\n` +
                              `**Tool ID**: \`${{ steps.build.outputs.id }}\`\n` +
                              `**Package Name**: \`${{ steps.tool.outputs.package }}\`\n` +
                              `**Name**: ${{ steps.tool.outputs.name }}\n` +
                              `**Version**: ${{ steps.build.outputs.version }}\n` +
                              `**Download URL**: ${{ steps.upload.outputs.url }}\n\n` +
                              `@${creator} your tool is now available in the Power Platform Tool Box marketplace!`
                      });

                      await github.rest.issues.update({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: context.issue.number,
                        state: 'closed',
                        labels: ['published']
                      });
